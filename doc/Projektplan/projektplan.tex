\documentclass[a4paper]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{cmbright}
\usepackage{url}
\usepackage{booktabs}
\usepackage[ngerman]{babel}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{minted}

\begin{document}
\title{
  Projekt: kitovu \\
  \Large{Projektplan} \\[3em]
  \includegraphics[width=20em]{../../img/logo/kitovu.jpg}
}
\author{
  Florian Bruhin \\ \url{florian.bruhin@hsr.ch} \and
  Méline Sieber \\ \url{meline.sieber@hsr.ch} \and
  Nicolas Ganz \\ \url{nicolas.ganz@hsr.ch} \and
  Marco Zollinger\footnote{Eine definitive Antwort der Schulleitung steht
    weiterhin aus. Momentan ist aber damit zu rechnen, dass Marco Zollinger
    leider nicht am EPJ teilnehmen kann.} \\ \url{marco.zollinger@hsr.ch}}
\date{\today}

\maketitle
\pagebreak

\section*{Änderungsgeschichte}

\begin{tabular}{llp{20em}l}
\toprule
Datum & Version & Änderung & AutorIn \\
\midrule
24.02.2018 & 1.1 & Struktur von Template übernommen, Projektantrag-Daten eingefügt, grobe Roadmap anhand der EPJ-Anleitung erstellt & Méline Sieber \\
26.02.2018 & 1.2 & Migration nach \LaTeX{}, diverse Vervollständigungen & Florian Bruhin \\
\bottomrule
\end{tabular}
\pagebreak

\section{Einführung}
\subsection{Zweck}
Der Projektplan zu \emph{kitovu} gibt eine Vogelperspektive zum Engineering-Projekt. Er steckt den Rahmen ab, innerhalb dessen \emph{kitovu} vollendet wird. Diese Übersicht umfasst eine Projektübersicht, wie das Projekt organisiert ist, welche Phasen das Projekt durchläuft und die Besprechungen mit dem Betreuer organisiert sind. Zudem bespricht der Projektplan mögliche Risiken, umreisst die anstehenden Arbeitspakete und listet die wichtigen Punkte, um eine hohe Qualität des Codes, der Dokumentation und des Projekt-Managments zu garantieren.

\subsection{Gültigkeitsbereich}
FIXME
% < Gültigkeitsbereich des Dokumentes>

\subsection{Referenzen}
FIXME
% <Liste aller verwendeten und referenzierten Dokumente, Bücher, Links, usw.>
% <Referenz auf ein Glossar Dokument, wo alle Abkürzungen und unklaren Begriffe erklärt werden>
% <Die Quellen / Referenzen sollten mit dem Word Tool automatisch erstellt werden>

\section{Projekt-Übersicht}
% <Kurze Beschreibung des Projektes>
Kitovu ist ein Software-Client für Studentinnen und Studenten der HSR, mit dem sie von verschiedenen Quellen Unterrichtsmaterialien lokal auf den eigenen Rechner synchronisieren können.

\subsection{Zweck und Ziel}
% <Sinn und Zweck des Projektes, sowie Zielsetzung und auch persönliche Ziele>
An der HSR müssen sich die Studentinnen und Studenten bislang ihre Unterrichtsmaterialien vom Skripteserver, von Moodle und anderen Orten von Hand zusammensuchen. Das ist aufwändig und unübersichtlich. \emph{Kitovu} soll das ändern: ein Client, der von verschiedenen Plattformen ausgewählte Unterrichtsmaterialien auf den eigenen Rechner synchronisiert.
Zielgruppe sind primär Studierende, sekundär Dozierende der HSR. Der Client könnte potentiell an anderen Hochschulen eingesetzt werden.

\subsubsection{Persönliche Ziele}
\begin{description}
\item[Nicolas Ganz] FIXME
\item[Florian Bruhin] Erfahrungen sammeln bei der ``Leitung'' eines kleinen
  Software-Teams, einige neue nützliche Tools ausprobieren, und das Endprodukt
  selbst: Endlich alle HSR-Dokumente zu einem Modul problemlos an einem Ort!
\item[Méline Sieber] Ausbau der Python-Programmierfähigkeiten und -kenntnisse (keine grosse Erfahrung vorhanden); erstes komplexeres Softwareprojekt durchziehen; Test-Erfahrung sammeln
\item[Marco Zollinger] Schritt von Python als Skriptsprache hin zur Verwendung in einem Softwareprojekt mit professionellem Workflow und Tools; Erfahrungen sammeln über Softwareentwicklung mit mehreren Personen und der dazugehörigen Arbeitsteilung und Kommunikation; Beitrag leisten in einem Open Source-Projekt das hoffentlich auch anderen Studenten zugute kommt; Kenntnisse in GUI-Entwicklung mit PyQt5 verbessern.

\end{description}

\subsection{Lieferumfang}
% <Konkreten Lieferumfang des Projektes beschreiben>
Kitovu bindet den Skripteserver ein. Der Terminal-basierte Client funktioniert mittels Profilen zu unterschiedlichen Plattformen (Moodle, Skripteserver, Studentenportal). Pro Profil sind Verbindungsdaten und eventuelle Login-Credentials im Client hinterlegt. Die Daten-Synchronisation erfolgt immer nur von Server zu Client, erfolgreiche und misslungene Datentransfers werden protokolliert.

Pro Profil lässt sich Folgendes definieren:

\begin{itemize}
\item welche Ordner/Dateien synchronisiert werden sollen.
\item welche Ordner/Dateien von der Synchronisation ausgeschlossen werden sollen.
\item wie mit Duplikaten/lokal bestehenden Dateien umgegangen werden soll.
\end{itemize}

% \item FIXME: Plattform-Plugin-Framework: zu definieren, vermutlich pluggy

Kitovu ist ausbaubar und damit modular: Zusätzlich zu den beiden Plattformen (Skripteserver, Moodle/Studentenportal) können in zukünftigen Projekten beliebig viele Plattformen als separates Plugin realisiert werden.

Optionale Features:

\begin{itemize}
\item Moodle und/oder das Studentenportal. Die Implementation von Moodle oder dem Studentenportal ist abhängig von den weiter unten beschriebenen Risiken.
\item Komplettes GUI, das der Funktionalität des Terminalprogramms entspricht.
\end{itemize}

\subsection{Annahmen und Einschränkungen}
% <Annahmen die für diesen Projektplan getroffen werden und Einschränkungen denen er unterliegt>
Wir berücksichtigen keine HSR-externen Anbieter wie etwa Dropbox, OneDrive, GoogleDrive.

Support für macOS ist keine Priorität, auch wenn wenn die Infrastruktur dafür
grundsätzlich existiert und dies durch Python kein Problem darstellen sollte.
Wir werden die Tests initial auf macOS laufen lassen, sollte es da aber zu
Problemen kommen, werden wir die Tests auf macOS ausschalten.

\section{Projektorganisation}
% <Kurze Beschreibung der Projektstruktur>
FIXME

\subsection{Organisationsstruktur}
% <Projektmitglieder nennen und deren Aufgaben und Verantwortungen aufzählen>
\begin{description}
\item[Florian Bruhin] Project Leader, Python Overseer-Wizard, Code-Quality-Garantierer
\item[Nicolas Ganz] JIRA/Confluence-Wizard, Meeting-Leader, Code Monkey
\item[Marco Zollinger] Code Monkey, Protokoll-Sekretärin, GUI ?
\item[Méline Sieber] Code Monkey, Grammar Nazi, Deadline-Auf-die-Finger-klopfen, Kommunikation mit Externen inklusive Betreuer
\end{description}

FIXME
% Wer testet? (siehe unten)
% Requirements: Domain-Modell, Use Cases schreiben, nicht-funktionale Anforderunge, GUI-Design
% Wer klopft allen auf die Finger, wenn Deadlines anstehen?
% Wer (externes!) testet das Programm?

\subsection{Externe Schnittstellen}
% FIXME
% <Ansprechpartner, verantwortliche Personen, Betreuer, usw. aufzählen>

\begin{itemize}
  \item Daniel Keller (\url{daniel.keller@hsr.ch}) als unser Betreuer für das Engineering-Projekt.
  \item Frank Koch (\url{frank.koch@hsr.ch}) als verantwortliche Person für das HSR-Moodle. 
  \item Raphael Zimmermann (\url{raphael.zimmermann@hsr.ch}) als Hauptentwickler
    von \emph{OpenHSR
      Connect\footnote{\url{https://github.com/openhsr/connect}}}, welches die
    Inspiration für unser Projekt darstellt, aber nur den Skripteserver
    unterstützt.
  \item Externe Tester: Für Usability- und Beta-Tests wollen wir verschiedene
    HSR-Studierende kontaktieren, ggf. auch mit einem Aufruf via e-Mail. Da das
    Tool von jedem HSR-Studierenden nutzbar sein soll, sollte es kein Problem
    darstellen, dafür kurzfristig Probanden zu finden.
\end{itemize}

Frank Koch und Raphael Zimmermann wurden bereits über unser Projekt informiert
und unterstützen unser Vorhaben gerne.

\section{Management-Abläufe}
\subsection{Kostenvoranschlag}
% <Wie viel Zeit steht zur Verfügung? In welcher Zeitspanne läuft das Projekt? Wird das Projekt früher beendet, dafür wöchentlich mehr gearbeitet?>

Da es sich bei dem EPJ um ein Modul mit 4 ECTS mit vollem Aufwand im Semester handelt, ist mit einem Richtwert von 120 Stunden pro Person zu rechnen.
Mit der Annahme, dass Marco Zollinger leider nicht im Projekt dabei sein wird,
fällt also ein totaler Aufwand von $3 \cdot 120 = 360$ Stunden an.

Wir wollen die vollen 15 Wochen für das Projekt ausnutzen, womit wöchentlich
durchschnittlich pro Person ein Arbeitsaufwand von $120 / 15 = 8$ Stunden zu
leisten ist.


\subsection{Zeitliche Planung}
% <Kurze Beschreibung der zeitlichen Planung und mit einer Grafik einen Überblick über die Phasen, Iterationen und Meilensteine geben. Das Datum des Eintreffens der Meilensteine sollte in der Phasenübersicht ersichtlich sein.>

Wir nutzen das in der Vorlesung empfohlene ``Scrum plus end of
elaboration''-Modell, wobei wir eine zusätzliche Training-Phase hinzufügen
(siehe unten). Eine Iteration soll dabei eine Woche dauern.


\textbf{(Übernommen von der Kurzeinführung)}

\begin{tabular}{llp{16em}l}
\toprule
KW & Sem.-Woche & Milestone & Review \\
\midrule
8 & 1 & M0 - Abgabe Projektantrag & \\
9 & 2 & M2 - Abgabe Projektplan & \\
10 & 3 & & Review Projektplan mit Note \\
11 & 4 & M2 - Requirements: Use Cases, Domain Model, nicht-funktionale Anforderung, GUI-Design & \\
12 & 5 & & Review Anforderungen \\
13 & 6 & M3 - End of Elaboration & \\
14 & 7 & & Review End of Elaboration \\
15 & 8 & M4 - Architektur: Schichten, Serverlogik, Persistenz, Deployment & \\
16 & 9 & & Review Architektur \\
17 & 10 & M5 - Usability-Test: Alpha-Release & \\
18 & 11 & & \\
19 & 12 & M6 - Feature-Freeze & Review Qualität \\
20 & 13 & & \\
21 & 14 & & \\
22 & 15 & & Schluss-Präsentation \\
\bottomrule
\end{tabular}

% TODO: Folgende Reviews müssen enthalten sein:
% 1. Review Projektplan mit Zeitplan und aktuellen Iterationsplänen – Termin: SW03
% 2. Review der Anforderungsspezifikation und der Domainanalyse – Termin: frei wählbar
% (empfohlen: vor End of Elaboration)
% 3. Ende Elaboration (s. Checkliste) mit Architekturprototyp – Termin: wählbar SW05-08
% 4. Review von Architektur/Design und Architekturdoku – Termin: wählbar bis SW14*)
% 5. Q-Review: Code-Qualität (u.a. Metriken), Tests und weitere Q-Massnahmen – Termin:
% wählbar nach End of Elaboration bis SW14*)
% 6. Schlusspräsentation und Demo der Software: SW15 (genaues Datum wird bekanntgegeben)

\subsubsection{Phasen / Iterationen}

\paragraph{Phase 1: Elaboration}

FIXME

% <Kurze Beschreibung und Dauer der Phase angeben>
% \subparagraph{FIXME: Bezeichnung der einzelnen Iterationen}
%<Kurze Beschreibung und Dauer der Iteration angeben>
%<Vorgehen bei Iterationsplanung und Iterationsassessment>

\paragraph{Phase 2: Training}

Da Méline, Nicolas und Marco noch Python-Anfänger sind und es auch eines der
Ziele ist, im Engineering-Projekt Erfahrung zu sammeln, haben wir eine separate
Training-Phase eingeplant. Darin wird Florian den anderen Team-Mitgliedern eine
Einführung in die Themen und Technologien geben, die beim Projekt benutzt
werden.

Danach sollten die Mitglieder das Wissen soweit möglich autodidaktisch erwerben,
wobei Florian gerne beratend zur Seite steht.

\paragraph{Phase 3: Construction}

\paragraph{Phase 4: Feature Freeze}

In der letzten Phase des Projekts tritt der \emph{feature freeze} ein. Es darf
keine neue Funktionalität mehr hinzugefügt werden und wir konzentrieren uns auf
Testing, Dokumentation und die Behebung von Bugs.

\subsubsection{Meilensteine}
\paragraph{FIXME: Bezeichnung der einzelnen Meilensteine}
% <Setzen Sie in Ihrem Projekt 6-8 Meilensteine. Kurze Beschreibung der Meilensteine mit genauem Datum. In der Regel auf Ende jeder Iteration einen Meilenstein setzen (diese Faustregel gilt nur für die SE-2Projekte, in realen Projekten haben Sie oft deutlich mehr Iterationen als Meilensteine, weil Meilensteine dort die nach aussen kommunizierten Ereignisse sind). Schreiben Sie zu jedem Meilenstein auf, welche Arbeitsprodukte (work products) Sie dann abliefern werden . Spezifizieren Sie wenn nötig auch den Fertigstellungsgrad der Arbeitsprodukte, z.B. „Zentrale Use Cases ‚fully dressed‘, restliche UCs im ‚brief‘ Format“, oder „Architekturskizze inkl. Definition der Interfaces zwischen Sub-Systemen und Deployment Diagramm“>

\subsection{Besprechungen}
% <regelmässige Besprechungen nennen (wann, wo, wer, Ziel und/oder Grund)>
\begin{itemize}
\item Gesamt-Teamsitzung: Dienstag und Mittwoch ab 17 Uhr, Mittwoch von 12-13 Uhr. Koordination, Klärung von Fragen, Besprechung des weiteren Verlaufs.
\item Gemeinsame Arbeit, nach Bedarf: Florian Bruhin und Marco Zollinger, Montag-Nachmittag ab 13 Uhr. Individuelles Arbeiten am Projekt.
\item Gemeinsame Arbeit, nach Bedarf: Méline Sieber und Nicolas Ganz, Mittwoch von 10-13 Uhr. Individuelles Arbeiten am Projekt.
\item Gemeinsame Arbeit, nach Bedarf: Marco Zollinger, Méline Sieber und Florian Bruhin, Freitag ab 15 Uhr (in KW 9, 11, 14, 16, 18, 20, 22). Individuelles Arbeiten am Projekt.
\end{itemize}

\section{Risikomanagement}
\subsection{Risiken}
% <Verweis auf Dokument TechnischeRisiken.xlsx>
FIXME

Die Moodle-Anbindung könnte nach Rücksprache mit einem der Administratoren, Frank Koch, zu Schwierigkeiten führen (Gespräch geführt am 21.2.2018). Es existiert eine WebDAV-Schnittstelle, die jedoch unter Umständen nicht für das Projekt geöffnet werden kann. 

Für das Studentenportal ist der OpenHSR-Verein verantwortlich, Kontaktperson ist XXX.

\subsection{Umgang mit Risiken}
% <Begründungen zur Tabelle. Weitere Beschreibungen zu Massnahmen und Vorbeugungen. Werden Reserven /Rückstellungen eingeplant? Wieso und wie viele? Wann werden Risiken qualitätssichernd überprüft (Vorgehen und Zeitpunkt(e) zur Neubeurteilung der Risiken)?>

\section{Arbeitspakete}
FIXME

% <Definieren Sie in einem separaten Tool (Redmine oder XLS, o.a.) diejenigen Arbeitspakete, die Ihnen zu Beginn des Projektes schon mal einfallen. Zu Beginn können Pakete eher generisch ausfallen (z.B. ‚Domainmodell erstellen‘ oder ‚GUI Programmieren‘, oder ‚ Usability Testing‘).
%
%Denken Sie daran, dass es in jedem Projekt auch eine ganze Reihe von ‚overhead‘-Tätigkeiten gibt: Projektleitung und -Sitzungen, Aufsetzen der Server und Werkzeuge, Qualitätsmassnahmen, Schlusspräsentation erstellen und anderes mehr – alles Tätigkeiten, die nicht direkt zum Software-Produkt führen. Planen Sie genug Zeit auch für diese Tätigkeiten ein.
%
%Dann sollte es in jeder Projektplanung einige projektspezifische Arbeitspakete geben, wie sie so nicht in anderen Projekten vorkommen (z.B. ‚ Level-Editor entwerfen‘, oder ‚Verifikation der Zahlungsangaben programmieren‘). Wenn es keine solchen Arbeitspakete gibt, ist der Projektplan zu generisch. Das heisst auch, dass man sich zu wenig Gedanken über die anfallenden Arbeiten gemacht hat.
%
%Später im Projekt werden Sie die Arbeitspakete noch verfeinern, verschieben, jemandem zuordnen, neu schätzen, etc. Deswegen empfiehlt sich der Einsatz eines Werkzeuges wie Redmine.
%
%Dokumentieren Sie URL und Logins auf das Projektmanagement Tool, in welchem die Meilensteine und die dazugehörigen Arbeitspakete erfasst sind.>

\section{Infrastruktur}
%<Benötigte Infrastruktur aufzählen. Spezielle Geräte, Laptop , Tools usw. und nötigenfalls aufzeigen für welche Bereiche diese verwendet werden. Eventuell auch Verfahren beschreiben (auf Tools bezogen).>
\begin{itemize}
  \item Jira-Server auf keltec.ch für Issue-Tracking und Projektmanagement
    (betrieben von Nicolas Ganz)
  \item Confluence-Server auf keltec.ch als Wiki (betrieben von Nicolas Ganz)
  \item Der Code liegt auf GitHub.
    Wir benutzen GitHub Pull Requests für Code Review, nicht aber Issues ($\rightarrow$ Jira)
    und das Wiki ($\rightarrow$ Confluence)
  \item Wir benutzen Travis CI\footnote{\url{https://travis-ci.com/}} (Linux und
    ggf. macOS) sowie AppVeyor\footnote{\url{https://www.appveyor.com/}} als
    externe CI (continuous integration) Anbieter.
\end{itemize}

\section{Qualitätsmassnahmen}
% <Was wird unternommen damit das Produkt des Projektes, sowie dessen gesamter Verlauf eine hohe Qualität erreicht? Übersicht in einer Tabelle geben mit Massnahmen, Zeitraum und Ziel der Massnahme>
%
%Bezug zur Roadmap weiter oben.

Wir setzen zur Qualitätssicherung auf verschiedene Tools sowie Code Reviews,
welche nachfolgend genauer beschrieben werden. Diese Tools werden in der
Elaboration-Phase eingerichtet und dann über die ganze Laufzeit des Projekts
eingesetzt.

\subsection{Dokumentation}
%<Wo befinden sich die Dokumente (SVN oder Git Server) und wie wird deren Qualität sichergestellt?>

Wir unterscheiden zwischen vier Arten der Dokumentation:

\begin{itemize}
  \item Protokolle zu Treffen und Entscheidungen werden im Confluence (Wiki) protokolliert.
  \item Längere Dokumente die weitergegeben werden (wie beispielsweise dieses
    Dokument) werden mit \LaTeX{} verfasst und landen in einem
    \texttt{doc/}-Unterordner im GitHub-Repository
  \item Dokumentation für Endbenutzer wird in
    Sphinx\footnote{\url{http://www.sphinx-doc.org/}} geschrieben, welches das
    Standardwerkzeug für die Python-Community (und auch darüber hinaus, wie
    beispielsweise den Linux-Kernel) darstellt.
  \item Code-Dokumentation wird ebenfalls mit Sphinx verfasst, mit im Code
    eingebetteten Python \emph{docstrings} (ähnlich zu JavaDoc).
\end{itemize}

\subsection{Projektmanagement}
%<Welches Tool wird für Projektmanagement eingesetzt (z.B. Redmine oder Trac) und wie erfolgt dieser Einsatz? Dazugehörige Links und Logins (Gastbenutzer).>
Das Projekt verwendet Jira und Confluence, um \emph{kitovu} zu managen, zu koordinieren und Arbeitspakete zu verteilen. Via Jira läuft auch die Zeiterfassung.

\subsection{Entwicklung}
%<Wo befindet sich der Source Code (z.B. SVN oder Git) und wie wird dessen Qualität sichergestellt?>
Der Source-Code befindet sich auf Github im Repository \texttt{kitovu-bot/kitovu\footnote{\url{https://github.com/kitovu-bot/kitovu}}}.

Wie unter \ref{sec:codereviews} beschrieben, setzen wir auf das
Vier-Augen-Prinzip mit Code Reviews.

Ausserdem setzen wir auf diverse Tools (bekannt als
linting/metrics/formatting/static analysis) um konsistenten und möglichst
fehlerfreien Code zu garantieren. Diese werden unter \ref{sec:tools} kurz beschrieben.

\subsubsection{Vorgehen}
% <Vorgehen in der Entwicklung>

\subsubsection{Tools}
\label{sec:tools}

\paragraph{Type annotations} Mittels sogenannten \emph{type annotations} (auch
bekannt als \emph{gradual typing}) wird die Typensicherheit im Code geprüft.
Ähnlich zu Typescript erzwingt die Sprache selber keine expliziten
Typendeklarationen (dynamic typing), jedoch sind diese valide Python-Syntax und
werden einfach ignoriert. Dadurch ist kein separater ``pre-compiler'' wie bei
Typescript nötig, jedoch ein externes Tool zur Überprüfung der Typen.

Beispiel von Typenannotationen:

\begin{minted}{python}
  def calc_primes(start: int) -> List[int]:
      primes: List[int] = []
      ...
\end{minted}

Wir benutzen dazu das Tool \emph{mypy\footnote{\url{http://mypy-lang.org/}}}.
Ursprünglich im Rahmen einer Doktorarbeit an der Universität Cambridge
entwickelt hat es sich zum etablierten Werkzeug entwickelt und wird durch Firmen
wie Dropbox benutzt und weiter entwickelt.

Als Alternative dazu wollen wir uns kurz
\emph{pytype\footnote{\url{https://github.com/google/pytype}}} von Google
anschauen, wobei die Wahl vermutlich auf mypy als das bekanntere Werkzeug fallen wird.

\paragraph{pylint} Das \emph{pylint\footnote{\url{https://pylint.org/}}}-Projekt
kombiniert verschiedene Funktionalitäten in einem Werkzeug, welche die
Code-Qualität erhöhen. Es hilft bei der Einhaltung von code guidelines
(Zeilenlänge, Variablennamen, unbenutzte Imports, etc.), kann aber auch Fehler
finden und enthält verschiedene Metrics (Anzahl Klassen, Argumente, Members, etc.).

\paragraph{flake8} \emph{flake8\footnote{\url{http://flake8.pycqa.org/}}} ist
ein weiteres bekanntes Tool. Der Fokus liegt hier eher auf Style-Problemen,
flake8 macht im Gegensatz zu pylint keine tiefergehende statische Code-Analyse.
Es gibt zwar einige Überschneidungen mit pylint, trotzdem macht es Sinn, beide
Tools zu verwenden, da flake8 doch einige nützliche Checks hat, die in pylint
nicht vorhanden sind. Ausserdem ist es viel schneller und kann gut im Editor/IDE
eingebunden werden, um sofortiges Feedback zu kriegen.

\paragraph{yapf} Bei \emph{yampf\footnote{\url{https://github.com/google/yapf}}}
(Yet Another Python Formatter) von Google handelt sich um ein weiteres Tool aus
der Linting/Style-Ecke, welches Probleme auch automatisiert beheben kann. Wir
werden vermutlich primär auf pylint/flake8 setzen, aber es wäre schön, wenn wir
auch yapf testen könnten.

\paragraph{coala / GitMate} \emph{Coala\footnote{\url{https://coala.io/}}} ist
(im Zusammenspiel mit \emph{GitMate\footnote{\url{https://gitmate.io/}}}) ein
Tool, welches alle obengenannte Tools (und auch weitere, für andere Sprachen) in
einem Tool vereint. Es bietet auch die Möglichkeit, Probleme automatisch als
Kommentare für pull requests zu verfassen. Es wäre schön, wenn wir es in unseren
Workflow integrieren können, ist aber nicht zwingend notwendig.

\paragraph{Paketierung} Darüber hinaus gibt es weitere Tools welche die
korrekte Paketierung überprüfen bzw. erleichtern:
\emph{check-manifest\footnote{\url{https://github.com/mgedmin/check-manifest/}}}
sowie \emph{pyroma\footnote{\url{https://github.com/regebro/pyroma/}}}. Diese
wollen wir einsetzen, sobald dies Sinn macht - also vermutlich erst nach dem
Feature Freeze, wenn wir das Projekt für Linux/Windows/ggf. macOS pakettieren.

\subsubsection{Unit Testing}
% <Wo werden welche Unit Tests geschrieben um die Qualität sicherzustellen? Wie wird die Testabdeckung sichergestellt (z.B. durch EclEmma)?>

Wir benutzen \emph{pytest\footnote{\url{https://docs.pytest.org/}}} als Test
Framework. Während Python ein unittest-Framework mit einer JUnit-Ähnlichen API
eingebaut hat, vereinfacht pytest das Verfassen von Tests ungemein.

Wir nutzen ausserdem verschiedene plugins für pytest:

\begin{itemize}
\item \emph{coverage.py\footnote{\url{https://coverage.readthedocs.io/}}} für
    Test-Coverage sowie \emph{codecov.io\footnote{\url{https://codecov.io/}}}
    als online-Service (Kommentare in pull-requests bei geänderter Coverage).
\item \emph{pytest-qt\footnote{\url{https://pytest-qt.readthedocs.io/}}} für das
    automatisierte Testen der GUI
\item eventuell \emph{pytest-bdd\footnote{\url{https://github.com/pytest-dev/pytest-bdd/}}} für Behaviour-Driven-Testing (Cucumber/Gherkin)
\item eventuell \emph{hypothesis\footnote{\url{http://hypothesis.works/}}} für
  Fuzzing-Tests, wobei automatisch Test-Werte aufgrund von Typendeklarationen
  generiert werden. Es ist aber fraglich, inwieweit dies in diesem Projekt Sinn macht.
\end{itemize}

Die Tests müssen im GitHub pull-request enthalten sein. Ziel ist, dass die
Coverage bei keiner Änderung sinkt, und idealerweise am Ende des Projekts bei
über 90\% liegt.

\subsubsection{Code-Reviews}
\label{sec:codereviews}
%<Werden Code Reviews gemacht und wie werden diese gemacht?>

Nebst diversen Tools zur Qualitätssicherung (siehe unten) setzen wir auf GitHub
code reviews: Sämtlicher Code wird, bevor er in den Master-Branch des
Github-Repositories eingepflegt wird, nach dem Vier-Augen-Prinzip geprüft. Dies
nicht nur aus Qualitätsgründen, sondern auch, weil alle involvierten Personen
sehr viel aus code reviews lernen können.

Normalerweise werden die pull requests von Florian Bruhin in seiner Rolle als
technischem Projektleiter geprüft, wobei darauf geachtet wird, dass auch andere
Projektmitglieder genügend Zeit haben, den Code anzuschauen.

Für Änderungen von Florian selbst (oder falls Florian nicht reagieren sollte)
darf der Code auch von einem anderen Projektmitglied geprüft werden.

\subsubsection{Code-Style-Guidelines}
%<Welche Code Style Guidelines werden angewendet? Sie brauchen keine eigenen Guidelines zu erfinden. Am besten referenzieren Sie existierende Guidelines, mit denen Sie einverstanden sind. Evtl. noch Abweichungen dazu dokumentieren>
Wir verwenden PEP 8\footnote{\url{https://www.python.org/dev/peps/pep-0008/}}
(Python Enhancement Proposal), den offiziellen Style-Guide der Python
Foundation. Dieser wurde ursprünglich für Entwicklungen an Python selbst
konzipiert, hat sich aber als Standardwerk verbreitet und wird auch von den
Style-Checkern standardmässig verwendet.

\subsection{Testen}
\subsubsection {FIXME: Bezeichnung des Tests (z.B. Integrationstest oder Systemtest)}
%<Beschreibung der Durchführung, Umsetzung und Umfang der Tests. Wenn möglich mit Mengenangaben (wieviele Tests)>

\end{document}